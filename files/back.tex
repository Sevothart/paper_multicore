\section{System Model and Background}
\label{sec:back}

In this  work we  consider the periodic task model, in which a  task set  
$\tau$ is composed  of \textit{n}  implicit-deadline  tasks, $\tau$ = 
\{$\tau_1$, ... ,$\tau_n$\}, running on a single-processor. Each task  
$\tau_{i}$, where \textit{i} $\leq$  \textit{n} and \textit{i} $\geq$ $1$, has a 
 period \textit{$p_{i}$} and  a worst-case execution time (WCET) 
\textit{$e_{i}$}. A task $\tau_{i}$  releases a job at every \textit{$p_{i}$} 
time units. $r_i^j$ denotes the release time of the $j^{th}$ job of $\tau_{i}$, 
named $\tau_i^j$. The relative deadline of the task $\tau_i$ is equal to its 
period: $d_i$ $=$ $p_i$. The relation \textit{$e_{i}$}/\textit{$p_{i}$} defines 
the utilization of a task $\tau_{i}$, called $u_i$. The sum of all tasks' 
utilizations defines the total system utilization ($\sum_{i=1}^n u_i$). We 
assume that tasks suspend only to wait for a lock. We also assume that the task 
set is scheduled either by the Rate-Monotonic (RM) scheduling, when
fixed-priority (FP) policy is used, or by the Earliest Deadline First (EDF), 
when dynamic-priority policy is used. At run-time, resource access protocols 
may temporarily raised the tasks priorities. 

Tasks share $n_r$ serially-reusable resources, $R_1$,$\ldots$,$R_{n_r}$. 
$N_{i,q}$ denotes the maximum number of times that a job of $\tau_i$ accesses 
$R_q$. $L_{i,q}$ denotes the maximum critical section length required by 
$\tau_i$ when it uses $R_q$. The priority ceiling $C_q$ is equal to the 
priority of the highest-priority task that uses $R_q$. 

\subsection{Resource Access Protocols}

This sections presents an overview of the real-time synchronization protocols 
implemented in this work. The protocols are the Priority Inheritance Protocol 
(PIP), the Priority Ceiling Protocol (PCP), the Immediate Priority Ceiling 
Protocol (IPCP), and the Stack Resource Policy (SRP). For a complete overview 
of such protocols, please refer to~\cite{Liu:2000,Buttazzo:2011}.

PIP is a classic mechanism for sharing resources in a single-processor with
FP scheduling. It aims at avoiding priority inversion by 
elevating the priority of the tasks that hold a resource, when there are higher 
priority tasks waiting on the same resource. The priority of the running task 
is always the maximum priority of the tasks blocked on the resource, if it is 
higher that the original priority.

PCP is another classic algorithm for controlling priority inversion and 
bounding blocking time for a task set with shared resources. It differs from 
PIP in the sense that every resource has a priority ceiling $C_j$, defined as 
the maximum priority among all tasks that access the resource. Whenever another 
task blocks on a locked resource, the owner's priority is temporarily raised to
the resource ceiling for the remainder of its critical section. This reduces 
context-switching overhead and simplifies the implementation in comparison to 
PIP.

IPCP is a variant of PCP, aiming for performance and ease of implementation. 
The major difference is that the task owning the resource has its priority 
raised to the ceiling immediately when it first acquires the resource, and not 
when another task tries to lock the resource. The main effect of this change is 
a further reduction of context switching overhead.

SRP provides resource access control for dynamic scheduling policies, such 
as the EDF scheduler. Additionally to a priority, SRP 
assigns a preemption level $\pi_i$ to each task. $\pi_i$ is static, initialized 
at the task $\tau_i$ creation time, and remains the same for all of its job. 
The main property is that a task $\tau_a$ can only preempt another task 
$\tau_b$ if its preemption level $\pi_a$ is greater than $\pi_b$. Under EDF 
scheduling, this condition is satisfied when preemption levels are ordered 
inversely in respect to the tasks' relative deadlines, as in $\tau_a > \tau_b 
\Longleftrightarrow D_a < D_b$.

During execution, every resource is assigned a resource ceiling $C_{R_i}$. This 
ceiling is equal to the maximum preemption level of the tasks that would be 
blocked on the resource, when issuing their maximum request. Therefore, the 
resource ceiling is a dynamic value, and is a function of available units
of the semaphore: $C_{R_i} = max(\pi_i|\mu_i(R_k) > n_k$.

SRP also defines a system ceiling $\Pi_s$, which is the maximum current system 
ceiling between all tasks. This is a global, dynamic parameter that can change 
at any resource access or release. The main idea of SRP is that if a task is 
going to be blocked on a resource it cannot access, it will be not even be 
allowed to preempt execution of other tasks. Also, a task is not allowed to 
begin execution unless any task that could preempt it would not block waiting 
on a resource. This is achieved by the SRP Preemption Test: a task is not 
permitted to be executed unless its priority is highest amongst all ready tasks, 
and its preemption level is higher than the system ceiling.
