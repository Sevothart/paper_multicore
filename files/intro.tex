\section{Introduction}
\label{sec:intro}

Any concurrent operating system (OS) must offer some kind of protocol to 
control the access to shared resources (\emph{i.e.,} a piece of code, such as 
data structures, I/O devices, buffers, and so on) by competing tasks, thus 
ensuring \emph{mutual exclusion} in their respective critical 
sections~\cite{Liu:2000,Buttazzo:2011}. 

Typically, mutual exclusion is guaranteed by the use of binary semaphores, such 
as mutexes and suspension-based locks~\cite{Yang:2015}. Therefore, a task 
willing to enter a critical section must wait until another task, which holds 
the resource, exits the critical section. This is accomplished by calling the 
semaphore operations \emph{p} (or wait) and \emph{v} (or signal) before 
entering and after leaving each critical section, respectively.

Real-time embedded applications also use semaphores to synchronize access to 
shared resources. However, specific resource access protocols are required to 
avoid unbounded priority inversions~\cite{Liu:2000,Buttazzo:2011,Yang:2015}. 
For instance, consider a higher-priority task $\tau_a$ and a lower-priority 
task $\tau_b$, sharing a resource $R_1$. It might happen that $\tau_b$ is 
holding the resource $R_1$, but is preempted by $\tau_a$. Then, $\tau_a$ 
executes until it tries to enter the critical section. However, $\tau_a$ cannot 
continue, because the resource is already in use by $\tau_b$. Thus, a 
higher-priority task ($\tau_a$) is blocked by a lower-priority task ($\tau_b$) 
which can cause unpredictable delays if not properly handled.

In fact, priority inversion has caused many problems in real applications. For 
example, the mars pathfinder spacecraft reseted several times after landing 
Mars on July $4^{th}$, 1997, resulting in significant delays in capturing 
scientific data~\cite{Jones:1997,Reeves:1997}. This resetting was caused by the 
overran of a lower-priority task due to priority inversion, which triggered a 
watchdog timer. Fortunately, the developers were able to patch the spacecraft 
remotely to solve the problem.  

Several real-time resource protocols have been proposed to bound priority 
inversion and take the blocking time into consideration when performing 
schedulability analyses. These protocols can be divided in those for static 
schedulers (when task priorities do not change) and for dynamic schedulers 
(when task priorities may change during execution)\footnote{Note that in this 
work we only consider resource access protocols for Uniprocessors.}. Ceiling- 
and priority inheritance-based protocols~\cite{Sha:1990} are typically used in 
static scheduling, while the stack resource protocol (SRP)~\cite{Baker:1991} is 
typically used in dynamic scheduling.

In this work, we present a design and implementation of resource access 
protocols for uniprocessors, considering both static and dynamic scheduling 
approaches. More specifically, we present a design for the Priority Inheritance 
Protocol (PIP)~\cite{Sha:1990}, Priority Ceiling Protocol 
(PCP)~\cite{Sha:1990}, Immediate Priority Ceiling Protocol (IPCP), and 
SRP~\cite{Baker:1991}. Our design uses object-oriented techniques to 
maximize the software reuse and minimize the run-time overhead. We have 
implemented the proposed software design in a real-time operating system (RTOS) 
and evaluated the memory footprint and run-time overhead in a microcontrolled 
platform. Our results indicate that the proposed design allows software reuse 
and low overhead, providing schedulability ratios close to the theoretical 
ones. 
In summary, we make the following contributions in this paper:

\begin{itemize}
 \item We propose an object-oriented design for uniprocessor real-time resource 
access protocols. The focus is on software reuse and low overhead;
 \item We implement the proposed design in an RTOS and evaluate the memory 
footprint of this implementation as well as its run-time overhead on a 
microcontrolled platform. The maximum obtained overhead is less than 
20~\si{\micro\second}, considering both \emph{p} and \emph{v} operations;
 \item A comparison in terms of task set schedulability ratio among the 
protocols, considering their run-time overheads. Our results indicate that due 
to the low overhead, the schedulability ratio remains close to theoretical 
bounds, proving the efficiency of the proposed design.
\end{itemize}

The remainder of this paper is organized as follows. Section~\ref{sec:back} 
presents the system model and reviews the resource sharing protocols used in 
this work. Section~\ref{sec:des} shows the proposed design and implementation 
of the protocols. Section~\ref{sec:eval} evaluates the proposed design in an 
real-time operating system and real hardware platform. Section~\ref{sec:rel} 
presents the related work. Finally, Section~\ref{sec:conc} concludes the paper.
